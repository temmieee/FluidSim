#version 460 core

struct Ray {
	vec3 origin;
	vec3 direction;
};
struct Material {
	vec4 col;
	float roughness;
	float metallic;
	float emissive;
	float refractiveIndex;
};
struct Sphere {
	vec3 position;
	float radius;
	vec4 color;
	Material material;
};
struct HitInfo{
	vec3 position;
	vec3 normal;
	int sphereIndex;
	Material material;
};

layout (std430, binding = 1) buffer spheresBuffer {
	Sphere data[64];
};
layout (local_size_x = 32, local_size_y = 32, local_size_z=1) in;
layout (rgba32f, binding = 0) uniform image2D screen;
float RandomValue(inout uint seed)
{
seed*=(seed+195439)*(seed+124395)*(seed+845921);
return seed/4294967295.0;
}
float RandomValueNormalDistribution(inout uint seed)
{
	float theta= 2*3.14159265359*RandomValue(seed);
	float rho = sqrt(-2.0*log(RandomValue(seed)));
	return rho*cos(theta);
}
vec3 GetRandomDirection(inout uint seed)
{
float x=RandomValueNormalDistribution(seed);
float y=RandomValueNormalDistribution(seed);
float z=RandomValueNormalDistribution(seed);
vec3 vec=normalize(vec3(x,y,z));
return vec;
}
HitInfo GetHitInfoFromRay(Ray ray)
{
	HitInfo hitInfo;
	hitInfo.normal=vec3(0,0,0);
	hitInfo.position=vec3(0,0,0);
	hitInfo.sphereIndex=-1;
	float distance=99999999;
		for (int i=0;i<data.length();i++)
	{
		vec3 oc = ray.origin - data[i].position;
		float a = 2*dot(ray.direction, oc);
		if (a > 0.0) continue;
		float b = dot(oc, oc) - data[i].radius * data[i].radius;
		float intersectionState = a * a - 4*b;
		float curDistance=(-a-sqrt(intersectionState))/2;
		vec3 intersection=ray.origin + ray.direction * curDistance;
		vec3 normalTemp = normalize(intersection-data[i].position);
		if ((intersectionState >= 0.0)&&(distance>curDistance)) 
		{
			hitInfo.normal=normalTemp;
			hitInfo.position=intersection;
			hitInfo.sphereIndex=i;
			hitInfo.material=data[i].material;
			distance=curDistance;
		}
	}
	return hitInfo;
}
float SampleDensity(vec3 position, float stepSize)
{
	float density=0.0;
	for (int i=0;i<data.length();i++)
	{
		float dist=length(position-data[i].position);
		if (dist<data[i].radius)
		{
			density+=1.0-(dist/data[i].radius);
		}
	}
	return density*stepSize;
}

uniform float halffov;
void main()
{
	vec4 pixel = vec4(0,0,0, 1.0);
	//vec4 pixel = vec4(0.0, 0.5, 0.0, 1.0);
	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
	ivec2 dimensions = imageSize(screen);
	float y = float(pixelCoords.y*2-float(dimensions.y)) / float(dimensions.y);
	float x = float(pixelCoords.x*2-float(dimensions.x)) / float(dimensions.y);

	vec3 cameraPos = vec3(0, 2.0, -10f);
	vec3 rayOrigin= cameraPos+vec3(x, y,atan(halffov*3.14/180));
	vec3 rayDir = normalize(rayOrigin-cameraPos);
	
	HitInfo hitInfo;
	vec3 debug;
	vec3 col=vec3(1,1,1);
	vec3 light=vec3(0,0,0);
	uint repetition=100;
	for (int i=0;i<repetition;i++)
	{
		vec3 tempCol=vec3(1,1,1);
		vec3 tempLight=vec3(0,0,0);
		rayOrigin= cameraPos+vec3(x, y,atan(halffov*3.14/180));
		rayDir = normalize(rayOrigin-cameraPos);
		for (int j=0;j<10;j++)
		{
				Ray ray;
			ray.origin=rayOrigin;
			ray.direction=rayDir;
			HitInfo tempHitInfo=GetHitInfoFromRay(ray);
			if (tempHitInfo.sphereIndex==-1)
			{
			hitInfo.normal=vec3(0,0,0);
			hitInfo.position=vec3(0,0,0);
			tempCol=vec3(0,0,0);
				break;
			}
			hitInfo=tempHitInfo;
			rayOrigin=hitInfo.position+hitInfo.normal*0.0;
			uint rng=pixelCoords.x+pixelCoords.y*dimensions.x+dimensions.x*dimensions.y*i;
			rayDir=normalize(reflect(rayDir,hitInfo.normal)+GetRandomDirection(rng)*hitInfo.material.roughness);;
			tempLight+=hitInfo.material.emissive*tempCol;
			tempCol*=data[hitInfo.sphereIndex].color.xyz;
		}
		light+=tempLight/repetition;
	}	
	pixel =vec4(light, 1.0);
	//pixel=vec4(light, 1.0);
	//uint rng=pixelCoords.x+pixelCoords.y*dimensions.x;
	//pixel=vec4(GetRandomDirection(rng),1);
	imageStore(screen, pixelCoords, pixel);

}