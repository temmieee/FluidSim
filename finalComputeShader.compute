#version 460 core

vec3 GetWeight(vec3 p,vec3 v0, vec3 v1, vec3 v2) {
	float a = 1 / length(p- v0);
	float b = 1 / length(p- v1);
	float c = 1 / length(p- v2);
	return normalize(vec3(a, b, c));
}

vec3 Lerp3(vec3 v0, vec3 v1, vec3 v2, float a, float b, float c) {
	// Ensure weights sum to 1 for a true barycentric interpolation
	// If a, b, c are already normalized (a + b + c = 1), this step is not needed.
	// float sum_weights = a + b + c;
	// a /= sum_weights;
	// b /= sum_weights;
	// c /= sum_weights;

	return v0 * a + v1 * b + v2 * c;
}
struct Ray {
	vec3 origin;
	vec3 direction;
};
struct Material {
	vec4 col;
	float roughness;
	float metallic;
	float emissive;
	float refractiveIndex;
};
struct Sphere {
	vec3 position;
	float radius;
	vec4 color;
	Material material;
};
struct UV {
	float x, y;
};

struct Object {
	vec3 position;
	uint startFace;
	vec3 rotation;
	uint facesAmount;
	vec3 scale;
	int materialIndex;
	vec3 padding;
	uint priorityIndex;
};
struct HitInfo {
	vec3 position;
	vec3 normal;
	int objectIndex;
	Material material;
};


layout(std430, binding = 1) buffer spheresBuffer {
	Sphere data[64];
};
layout(std430, binding = 2) buffer vertexBuffer {
	vec4 vertexData[];
};
layout(std430, binding = 3) buffer normalBuffer {
	vec4 normalData[];
};
layout(std430, binding = 4) buffer uvBuffer {
	UV uvData[];
};
layout(std430, binding = 5) buffer faceBuffer {
	ivec4 faceData[];
};
layout(std430, binding = 6) buffer objectBuffer {
	Object objectData[];
};
layout(std430, binding = 7) buffer materialBuffer {
	Material materialData[];
};
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;
uniform uint objectAmount;
float RandomValue(inout uint seed)
{
	seed *= (seed + 195439) * (seed + 124395) * (seed + 845921);
	return seed / 4294967295.0;
}
float RandomValueNormalDistribution(inout uint seed)
{
	float theta = 2 * 3.14159265359 * RandomValue(seed);
	float rho = sqrt(-2.0 * log(RandomValue(seed)));
	return rho * cos(theta);
}
vec3 GetRandomDirection(inout uint seed)
{
	float x = RandomValueNormalDistribution(seed);
	float y = RandomValueNormalDistribution(seed);
	float z = RandomValueNormalDistribution(seed);
	vec3 vec = normalize(vec3(x, y, z));
	return vec;
}
HitInfo GetHitInfoFromRay(Ray ray)
{
	HitInfo hitInfo;
	hitInfo.normal = vec3(0, 0, 0);
	hitInfo.position = vec3(0, 0, 0);
	hitInfo.objectIndex = -1;
	float distance = 999999999;
	float kEpsilon = 0.000001;

	for (uint objIndex=0; objIndex <objectAmount; objIndex++)
	{
		
		HitInfo tempHitInfo;
		//tempHitInfo=hitInfo;
		tempHitInfo.normal = vec3(0, 0, 0);
		tempHitInfo.position = vec3(0, 0, 0);
		tempHitInfo.objectIndex = -1;
		for (uint i = objectData[objIndex].startFace; i< (objectData[objIndex].startFace+objectData[objIndex].facesAmount+1) * 3;i+=3)
		{
							
			vec3 v0 = vertexData[faceData[i].x].xyz+objectData[objIndex].position.xyz;
			vec3 v1 = vertexData[faceData[i+1].x].xyz+objectData[objIndex].position.xyz;
			vec3 v2 = vertexData[faceData[i+2].x].xyz+objectData[objIndex].position.xyz;
			vec3 v0v1 = v1 - v0;
			vec3 v0v2 = v2 - v0;
			vec3 N = cross(v0v1, v0v2);
			float NdotRayDirection = dot(N, ray.direction);
			if (abs(NdotRayDirection) < kEpsilon) // Almost 0
			{
				continue;
			}
			float d = -dot(N, v0);
			float t = -(dot(N, ray.origin) + d) / NdotRayDirection;
		
			if (t < 0) continue; // The triangle is behind

		
			// Compute the intersection point using equation 1
			vec3 P = ray.origin + t * ray.direction;
			vec3 Ne;// Vector perpendicular to triangle's plane
			 // Test sidedness of P w.r.t. edge v0v1
			vec3 v0p = P - v0;
			Ne = cross(v0v1, v0p);
			if (dot(N, Ne) < 0) continue;
			// Test sidedness of P w.r.t. edge v2v1
			vec3 v2v1 = v2 - v1;
			vec3 v1p = P - v1;
			Ne = cross(v2v1, v1p);
			if (dot(N, Ne) < 0) continue; // P is on the right side

			// Test sidedness of P w.r.t. edge v2v0
			vec3 v2v0 = v0 - v2;
			vec3 v2p = P - v2;
			Ne = cross(v2v0, v2p);
			if (dot(N, Ne) < 0) continue; // P is on the right side
			if (t > distance) continue;
			distance = t;
			vec3 actualNormalv0 = normalData[faceData[i].z].xyz;
			vec3 actualNormalv1 = normalData[faceData[i + 1].z].xyz;
			vec3 actualNormalv2 = normalData[faceData[i + 2].z].xyz;
			vec3 weight = GetWeight(P, v0, v1, v2);
			vec3 actualNormal = normalize(Lerp3(actualNormalv0, actualNormalv1, actualNormalv2, weight.x, weight.y, weight.z));
			tempHitInfo.position=P;
			tempHitInfo.normal=actualNormal;
			//tempHitInfo.objectIndex = int(objectData[objIndex].materialIndex);
			tempHitInfo.objectIndex = int(objIndex);
		}
		
		float dist=length(tempHitInfo.position-ray.origin);
		if (dist>distance+kEpsilon) continue;
		distance = dist;
		hitInfo=tempHitInfo;
	}
	return hitInfo;
}
float SampleDensity(vec3 position, float stepSize)
{
	float density = 0.0;
	for (int i = 0; i < data.length(); i++)
	{
		float dist = length(position - data[i].position);
		if (dist < data[i].radius)
		{
			density += 1.0 - (dist / data[i].radius);
		}
	}
	return density * stepSize;
}

uniform float halffov;
void main()
{
	vec4 pixel = vec4(0, 0, 0, 1.0);
	//vec4 pixel = vec4(0.0, 0.5, 0.0, 1.0);
	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
	ivec2 dimensions = imageSize(screen);
	float y = float(pixelCoords.y * 2 - float(dimensions.y)) / float(dimensions.y);
	float x = float(pixelCoords.x * 2 - float(dimensions.x)) / float(dimensions.y);

	vec3 cameraPos = vec3(0, 4, -5f);
	vec3 rayOrigin = cameraPos + vec3(x, y, atan(halffov * 3.14 / 180));
	vec3 rayDir = normalize(rayOrigin - cameraPos);

	HitInfo hitInfo;
	vec3 debug;
	vec3 col = vec3(1, 1, 1);
	vec3 light = vec3(0, 0, 0);
	uint repetition = 1;
	float distance;
	for (int i = 0; i < repetition; i++)
	{
		vec3 tempCol = vec3(1, 1, 1);
		vec3 tempLight = vec3(0, 0, 0);
		rayOrigin = cameraPos + vec3(x, y, atan(halffov * 3.14 / 180));
		rayDir = normalize(rayOrigin - cameraPos);
		for (int j = 0; j < 1; j++)
		{
			Ray ray;
			ray.origin = rayOrigin;
			ray.direction = rayDir;
			hitInfo.normal = vec3(0, 0, 0);
			HitInfo tempHitInfo = GetHitInfoFromRay(ray);
			if (tempHitInfo.objectIndex == -1)
			{
				hitInfo.position = vec3(0, 0, 0);
				hitInfo.normal = vec3(0, 0, 0);
				break;
			}
			hitInfo = tempHitInfo;
			rayOrigin = hitInfo.position + hitInfo.normal * 0.0001;
			uint rng = pixelCoords.x + pixelCoords.y * dimensions.x + dimensions.x * dimensions.y * i;
			rayDir = normalize(reflect(rayDir, hitInfo.normal) + GetRandomDirection(rng) * 0);
			tempLight += materialData[hitInfo.objectIndex].emissive * tempCol;
			tempCol *= materialData[hitInfo.objectIndex].col.xyz;
		}
		light += light / repetition;
	}
	pixel = vec4(hitInfo.normal, 1.0);
	//pixel=vec4(light, 1.0);
	//uint rng=pixelCoords.x+pixelCoords.y*dimensions.x;
	//pixel=vec4(GetRandomDirection(rng),1);
	imageStore(screen, pixelCoords, pixel);

}